# -*- coding: utf-8 -*-
"""Glass Identification Data Set

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZZZ8pjILuZLfU8w14BnALXSvM-cZ1Ggw
"""

import pandas as pd
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report
from scipy.spatial import distance

train = pd.read_csv("/content/trainKNN.txt", header=None)
train.columns = ['ID', 'RI', 'Na', 'Mg', 'Al', 'Si', 'K', 'Ca', 'Ba', 'Fe', 'Type of glass']
train = train.drop('ID', axis=1)

test = pd.read_csv('/content/testKNN.txt', header=None)
test.columns=['ID', 'RI', 'Na', 'Mg', 'Al', 'Si', 'K', 'Ca', 'Ba', 'Fe', 'Type of glass']
test = test.drop('ID', axis=1)

train.head()

test.head()

train.describe()

test.describe()

def standardize (df):
    for col in df.columns:
        if col != "Type of glass": 
            df[col] = (df[col] - df[col].mean())/df[col].std()
    return df

train = standardize(train)
test = standardize(test)

x_train = train.drop(["Type of glass"], axis=1)
y_train = train["Type of glass"]

x_test = test.drop("Type of glass", axis=1) 
y_test = test["Type of glass"]

euclid_model = KNeighborsClassifier(n_neighbors=8, metric=distance.sqeuclidean) # Square Euclidean distance model
euclid_model.fit(x_train,y_train)

manhattan_model = KNeighborsClassifier(n_neighbors=8, metric=distance.cityblock) # Manhattan distance model
manhattan_model.fit(x_train, y_train)

manhattan_predictions = manhattan_model.predict(x_test)
euclid_predictions = euclid_model.predict(x_test)

df = pd.DataFrame({'actual': y_test, 'manhattan': manhattan_predictions, 'euclid': euclid_predictions})
df.head()

manhattan_count = len(df.loc[df['manhattan'] == df['actual']])
print('Manhattan Accuracy: {}%'.format(round(100*manhattan_count/len(df), 2)))
print(classification_report(y_test, manhattan_predictions, target_names=df['actual'].astype(str).unique()))

euclid_count = len(df.loc[df['euclid'] == df['actual']])
print('Square Euclidean Accuracy: {}%'.format(round(100*euclid_count/len(df), 2)))
print(classification_report(y_test, euclid_predictions, target_names=df['actual'].astype(str).unique()))